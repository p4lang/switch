/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>

#include "switch_sai_rpc.h"

#ifdef P4THRIFT
#include <p4thrift/protocol/TBinaryProtocol.h>
#include <p4thrift/server/TSimpleServer.h>
#include <p4thrift/transport/TServerSocket.h>
#include <p4thrift/transport/TBufferTransports.h>

namespace thrift_provider = p4::thrift;
#else
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

namespace thrift_provider = apache::thrift;
#endif

#include <arpa/inet.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <sai.h>
#ifdef __cplusplus
}
#endif

#include <saifdb.h>
#include <saivlan.h>
#include <sairouter.h>
#include <sairouterintf.h>
#include <sairoute.h>
#include <saiswitch.h>
#include <saimirror.h>
#include <saistatus.h>

#include "arpa/inet.h"

using namespace ::thrift_provider;
using namespace ::thrift_provider::protocol;
using namespace ::thrift_provider::transport;
using namespace ::thrift_provider::server;

using boost::shared_ptr;

using namespace  ::switch_sai;

class switch_sai_rpcHandler : virtual public switch_sai_rpcIf {
 public:
  switch_sai_rpcHandler() {
    // Your initialization goes here
  }

  unsigned int sai_thrift_string_to_mac(const std::string s, unsigned char *m) {
      unsigned int i, j=0;
      memset(m, 0, 6);
      for(i=0;i<s.size();i++) {
          char let = s.c_str()[i];
          if (let >= '0' && let <= '9') {
              m[j/2] = (m[j/2] << 4) + (let - '0'); j++;
          } else if (let >= 'a' && let <= 'f') {
              m[j/2] = (m[j/2] << 4) + (let - 'a'+10); j++;
          } else if (let >= 'A' && let <= 'F') {
              m[j/2] = (m[j/2] << 4) + (let - 'A'+10); j++;
          }
      }
      return (j == 12);
  }

  void sai_thrift_string_to_v4_ip(const std::string s, unsigned int *m) {
      unsigned char r=0;
      unsigned int i;
      *m = 0;
      for(i=0;i<s.size();i++) {
          char let = s.c_str()[i];
          if (let >= '0' && let <= '9') {
              r = (r * 10) + (let - '0');
          } else {
              *m = (*m << 8) | r;
              r=0;
          }
      }
      *m = (*m << 8) | (r & 0xFF);
      *m = htonl(*m);
      return;
  }

  void sai_thrift_string_to_v6_ip(const std::string s, unsigned char *v6_ip) {
      const char *v6_str = s.c_str();
      inet_pton(AF_INET6, v6_str, v6_ip);
      return;
  }

  void sai_v4_ip_to_thrift_string(std::string s, unsigned int *m) {
      return;
  }

  void sai_to_v6_ip_thrift_string(std::string s, unsigned char *v6_ip) {
      return;
  }

  void sai_thrift_parse_object_id_list(const std::vector<sai_thrift_object_id_t> & thrift_object_id_list, sai_object_id_t *object_id_list) {
      std::vector<sai_thrift_object_id_t>::const_iterator it = thrift_object_id_list.begin();
      for(uint32_t i = 0; i < thrift_object_id_list.size(); i++, it++) {
          object_id_list[i] = (sai_object_id_t)*it;
      }
  }

  void sai_thrift_parse_vlan_member_attributes(const std::vector<sai_thrift_attribute_t> & thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t) *it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_VLAN_MEMBER_ATTR_VLAN_ID:
                  attr_list[i].value.u16 = attribute.value.u16;
                  break;
              case SAI_VLAN_MEMBER_ATTR_PORT_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_VLAN_MEMBER_ATTR_TAGGING_MODE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              default:
                  break;
          }
      }
  }

  void sai_thrift_parse_ip_address(const sai_thrift_ip_address_t &thrift_ip_address, sai_ip_address_t *ip_address) {
      ip_address->addr_family = (sai_ip_addr_family_t) thrift_ip_address.addr_family;
      if ((sai_ip_addr_family_t)thrift_ip_address.addr_family == SAI_IP_ADDR_FAMILY_IPV4) {
          sai_thrift_string_to_v4_ip(thrift_ip_address.addr.ip4, &ip_address->addr.ip4);
      } else {
          sai_thrift_string_to_v6_ip(thrift_ip_address.addr.ip6, ip_address->addr.ip6);
      }
  }

  void sai_thrift_deparse_ip_address(sai_thrift_ip_address_t &thrift_ip_address, sai_ip_address_t *ip_address) {
      thrift_ip_address.addr_family = (sai_thrift_ip_addr_family_t) ip_address->addr_family;
      if ((sai_ip_addr_family_t)thrift_ip_address.addr_family == SAI_IP_ADDR_FAMILY_IPV4) {
          sai_v4_ip_to_thrift_string(thrift_ip_address.addr.ip4, &ip_address->addr.ip4);
      } else {
          sai_to_v6_ip_thrift_string(thrift_ip_address.addr.ip6, ip_address->addr.ip6);
      }
  }

  void sai_thrift_parse_ip_prefix(const sai_thrift_ip_prefix_t &thrift_ip_prefix, sai_ip_prefix_t *ip_prefix) {
      ip_prefix->addr_family = (sai_ip_addr_family_t) thrift_ip_prefix.addr_family;
      if ((sai_ip_addr_family_t)thrift_ip_prefix.addr_family == SAI_IP_ADDR_FAMILY_IPV4) {
          sai_thrift_string_to_v4_ip(thrift_ip_prefix.addr.ip4, &ip_prefix->addr.ip4);
          sai_thrift_string_to_v4_ip(thrift_ip_prefix.mask.ip4, &ip_prefix->mask.ip4);
      } else {
          sai_thrift_string_to_v6_ip(thrift_ip_prefix.addr.ip6, ip_prefix->addr.ip6);
          sai_thrift_string_to_v6_ip(thrift_ip_prefix.mask.ip6, ip_prefix->mask.ip6);
      }
  }

  void sai_thrift_parse_attribute_ids(const std::vector<int32_t> &thrift_attr_id_list, sai_attribute_t *attr_list) {
      std::vector<int32_t>::const_iterator it = thrift_attr_id_list.begin();
      for(uint32_t i = 0; i < thrift_attr_id_list.size(); i++, it++) {
          attr_list[i].id = (int32_t) *it;
      }
  }

  void sai_thrift_parse_fdb_entry(const sai_thrift_fdb_entry_t &thrift_fdb_entry, sai_fdb_entry_t *fdb_entry) {
      fdb_entry->vlan_id = (sai_vlan_id_t) thrift_fdb_entry.vlan_id;
      sai_thrift_string_to_mac(thrift_fdb_entry.mac_address, fdb_entry->mac_address);
  }

  void sai_thrift_parse_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_PORT_ATTR_ADMIN_STATE:
                  attr_list[i].value.booldata = attribute.value.booldata;
                  break;
              case SAI_PORT_ATTR_PORT_VLAN_ID:
                  attr_list[i].value.u16 = attribute.value.u16;
                  break;
              case SAI_PORT_ATTR_QOS_DOT1P_TO_TC_MAP:
              case SAI_PORT_ATTR_QOS_DSCP_TO_TC_MAP:
              case SAI_PORT_ATTR_QOS_DOT1P_TO_COLOR_MAP:
              case SAI_PORT_ATTR_QOS_DSCP_TO_COLOR_MAP:
              case SAI_PORT_ATTR_QOS_TC_TO_QUEUE_MAP:
              case SAI_PORT_ATTR_QOS_TC_TO_PRIORITY_GROUP_MAP:
              case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP:
              case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              default:
                  break;
          }
      }
  }

  void sai_thrift_parse_route_entry(const sai_thrift_route_entry_t &thrift_route_entry, sai_route_entry_t *route_entry) {
      route_entry->vr_id = (sai_object_id_t) thrift_route_entry.vr_id;
      sai_thrift_parse_ip_prefix(thrift_route_entry.destination, &route_entry->destination);
  }

  void sai_thrift_parse_neighbor_entry(const sai_thrift_neighbor_entry_t &thrift_neighbor_entry, sai_neighbor_entry_t *neighbor_entry) {
      neighbor_entry->rif_id = (sai_object_id_t) thrift_neighbor_entry.rif_id;
      sai_thrift_parse_ip_address(thrift_neighbor_entry.ip_address, &neighbor_entry->ip_address);
  }

  void sai_thrift_parse_fdb_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_FDB_ENTRY_ATTR_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_FDB_ENTRY_ATTR_PORT_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_FDB_ENTRY_ATTR_PACKET_ACTION:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              default:
                  break;
          }
      }
  }

  void sai_thrift_parse_fdb_flush_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_FDB_FLUSH_ATTR_PORT_ID:
                  attr_list[i].value.oid = (sai_object_id_t) attribute.value.oid;
                  break;
              case SAI_FDB_FLUSH_ATTR_VLAN_ID:
                  attr_list[i].value.u16 = attribute.value.u16;
                  break;
              case SAI_FDB_FLUSH_ATTR_ENTRY_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
          }
      }
  }

  void sai_thrift_parse_vr_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V4_STATE:
              case SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V6_STATE:
                  attr_list[i].value.booldata = attribute.value.booldata;
                  break;
              case SAI_VIRTUAL_ROUTER_ATTR_SRC_MAC_ADDRESS:
                  sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                  break;
          }
      }
  }

  void sai_thrift_parse_route_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              default:
                  break;
          }
      }
  }

  void sai_thrift_parse_router_interface_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_ROUTER_INTERFACE_ATTR_VIRTUAL_ROUTER_ID:
              case SAI_ROUTER_INTERFACE_ATTR_PORT_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_ROUTER_INTERFACE_ATTR_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_ROUTER_INTERFACE_ATTR_VLAN_ID:
                  attr_list[i].value.u16 = attribute.value.u16;
                  break;
              case SAI_ROUTER_INTERFACE_ATTR_SRC_MAC_ADDRESS:
                  sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                  break;
              case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V4_STATE:
              case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V6_STATE:
                  attr_list[i].value.booldata = attribute.value.booldata;
                  break;
              default:
                  break;
          }
      }
  }

  void sai_thrift_deparse_router_interface_attributes(std::vector<sai_thrift_attribute_t> &out_attr_list,
          const std::vector<sai_thrift_attribute_t> &in_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = in_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < in_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          switch (attr_list[i].id) {
              case SAI_ROUTER_INTERFACE_ATTR_VIRTUAL_ROUTER_ID:
              case SAI_ROUTER_INTERFACE_ATTR_PORT_ID:
                  attribute.value.oid = attr_list[i].value.oid;
                  break;
              case SAI_ROUTER_INTERFACE_ATTR_TYPE:
                  attribute.value.s32 = attr_list[i].value.s32;
                  break;
              case SAI_ROUTER_INTERFACE_ATTR_VLAN_ID:
                  attribute.value.u16 = attr_list[i].value.u16;
                  break;
              case SAI_ROUTER_INTERFACE_ATTR_SRC_MAC_ADDRESS:
//                  sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                  break;
              case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V4_STATE:
              case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V6_STATE:
                  attribute.value.booldata = attr_list[i].value.booldata;
                  break;
              default:
                  break;
          }
          out_attr_list.push_back(attribute);
      }
  }

  void sai_thrift_parse_next_hop_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_NEXT_HOP_ATTR_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_NEXT_HOP_ATTR_IP:
                  sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                  break;
              case SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
          }
      }
  }

  void sai_thrift_deparse_next_hop_attributes(std::vector<sai_thrift_attribute_t> &out_attr_list, const std::vector<sai_thrift_attribute_t> &in_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = in_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < in_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          switch (attr_list[i].id) {
              case SAI_NEXT_HOP_ATTR_TYPE:
                  attribute.value.s32 = attr_list[i].value.s32;
                  break;
              case SAI_NEXT_HOP_ATTR_IP:
                  sai_thrift_deparse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                  break;
              case SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID:
                  attribute.value.oid = attr_list[i].value.oid;
                  break;
          }
          out_attr_list.push_back(attribute);
      }
  }

  void sai_thrift_parse_next_hop_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list, sai_object_id_t **nhop_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_NEXT_HOP_GROUP_ATTR_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_COUNT:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_NEXT_HOP_GROUP_ATTR_NEXT_HOP_MEMBER_LIST:
                  *nhop_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * attribute.value.objlist.count);
                  std::vector<sai_thrift_object_id_t>::const_iterator it2 = attribute.value.objlist.object_id_list.begin();
                  for (uint32_t j = 0; j < attribute.value.objlist.object_id_list.size(); j++, *it2++) {
                      (*nhop_list)[j] = (sai_object_id_t) *it2;
                  }
                  attr_list[i].value.objlist.count = attribute.value.objlist.count;
                  attr_list[i].value.objlist.list = *nhop_list;
                  break;
          }
      }
  }

  void sai_thrift_parse_next_hop_group_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_GROUP_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_WEIGHT:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
          }
      }
  }

  void sai_thrift_parse_lag_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list, sai_object_id_t **port_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_LAG_ATTR_PORT_LIST:
                  *port_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * attribute.value.objlist.count);
                  std::vector<sai_thrift_object_id_t>::const_iterator it2 = attribute.value.objlist.object_id_list.begin();
                  for (uint32_t j = 0; j < attribute.value.objlist.object_id_list.size(); j++, it2++) {
                      (*port_list)[j] = (sai_object_id_t) *it2;
                  }
                  attr_list[i].value.objlist.count = attribute.value.objlist.count;
                  attr_list[i].value.objlist.list = *port_list;
                  break;
          }
      }
  }

  void sai_thrift_parse_lag_member_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_LAG_MEMBER_ATTR_LAG_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_LAG_MEMBER_ATTR_PORT_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_LAG_MEMBER_ATTR_EGRESS_DISABLE:
                  break;
              case SAI_LAG_MEMBER_ATTR_INGRESS_DISABLE:
                  break;
          }
      }
  }

  void sai_thrift_parse_stp_port_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_STP_PORT_ATTR_STP:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_STP_PORT_ATTR_PORT:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_STP_PORT_ATTR_STATE:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
          }
      }
  }

  void sai_thrift_parse_stp_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list, sai_vlan_id_t **vlan_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_STP_ATTR_VLAN_LIST:
                  *vlan_list = (sai_vlan_id_t *) malloc(sizeof(sai_vlan_id_t) * attribute.value.vlanlist.vlan_count);
                  std::vector<sai_thrift_vlan_id_t>::const_iterator it2 = attribute.value.vlanlist.vlan_list.begin();
                  for (uint32_t j = 0; j < attribute.value.vlanlist.vlan_list.size(); j++, *it2++) {
                      *vlan_list[j] = (sai_vlan_id_t) *it2;
                  }
                  attr_list[i].value.vlanlist.count = attribute.value.vlanlist.vlan_count;
                  attr_list[i].value.vlanlist.list = *vlan_list;
                  break;
          }
      }
  }

  void sai_thrift_parse_neighbor_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_NEIGHBOR_ENTRY_ATTR_DST_MAC_ADDRESS:
                  sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                  break;
          }
      }
  }

  void sai_thrift_parse_hostif_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_HOSTIF_ATTR_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_HOSTIF_ATTR_RIF_OR_PORT_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_HOSTIF_ATTR_NAME:
                  memcpy(attr_list[i].value.chardata, attribute.value.chardata.c_str(), HOSTIF_NAME_SIZE);
                  break;
          }
      }
  }

  void sai_thrift_parse_hostif_trap_group_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_HOSTIF_TRAP_GROUP_ATTR_QUEUE:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_HOSTIF_TRAP_GROUP_ATTR_POLICER:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
          }
      }
  }

  void sai_thrift_parse_hostif_trap_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it1 = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
          attribute = (sai_thrift_attribute_t)*it1;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_HOSTIF_TRAP_ATTR_TRAP_CHANNEL:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_HOSTIF_TRAP_ATTR_TRAP_TYPE:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              default:
                  break;
          }
      }
  }

  void sai_thrift_parse_hostif_trap_attribute(const sai_thrift_attribute_t &thrift_attr, sai_attribute_t *attr) {
      attr->id = thrift_attr.id;
      switch (thrift_attr.id) {
          case SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION:
              attr->value.u32 = thrift_attr.value.u32;
              break;
          case SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY:
              attr->value.u32 = thrift_attr.value.u32;
              break;
          case SAI_HOSTIF_TRAP_ATTR_TRAP_CHANNEL:
              attr->value.u32 = thrift_attr.value.u32;
              break;
          case SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP:
              attr->value.oid = thrift_attr.value.oid;
              break;
          default:
              break;
      }
  }

  int32_t sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t &thrift_attr) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_port_api_t *port_api;
      status = sai_api_query(SAI_API_PORT, (void **) &port_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      std::vector<sai_thrift_attribute_t> thrift_attr_list;
      thrift_attr_list.push_back(thrift_attr);
      sai_attribute_t attr;
      sai_thrift_parse_port_attributes(thrift_attr_list, &attr);
      status = port_api->set_port_attribute((sai_object_id_t)port_id, &attr);
      return status;
  }

  int32_t sai_thrift_create_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_fdb_api_t *fdb_api;
      sai_fdb_entry_t fdb_entry;
      status = sai_api_query(SAI_API_FDB, (void **) &fdb_api);
      if (status != SAI_STATUS_SUCCESS) {
         return status;
      }
      sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_fdb_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = fdb_api->create_fdb_entry(&fdb_entry, attr_count, attr_list);
      free(attr_list);
      return status;
  }

  int32_t sai_thrift_delete_fdb_entry(const sai_thrift_fdb_entry_t& thrift_fdb_entry) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_fdb_api_t *fdb_api;
      sai_fdb_entry_t fdb_entry;
      status = sai_api_query(SAI_API_FDB, (void **) &fdb_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
      status = fdb_api->remove_fdb_entry(&fdb_entry);
      return status;
  }

  int32_t sai_thrift_flush_fdb_entries(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_fdb_api_t *fdb_api;
      status = sai_api_query(SAI_API_FDB, (void **) &fdb_api);
      if (status != SAI_STATUS_SUCCESS) {
         return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_fdb_flush_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = fdb_api->flush_fdb_entries(attr_count, attr_list);
      free(attr_list);
      return status;
  }

  int32_t sai_thrift_create_vlan(const sai_thrift_vlan_id_t vlan_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_vlan_api_t *vlan_api;
      status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = vlan_api->create_vlan((sai_vlan_id_t) vlan_id);
      return status;
  }

  int32_t sai_thrift_delete_vlan(const sai_thrift_vlan_id_t vlan_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_vlan_api_t *vlan_api;
      status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = vlan_api->remove_vlan((sai_vlan_id_t) vlan_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_vlan_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_vlan_api_t *vlan_api;
      sai_object_id_t vlan_member_id = 0;
      status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      uint32_t attr_count = thrift_attr_list.size();
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_vlan_member_attributes(thrift_attr_list, attr_list);
      status = vlan_api->create_vlan_member(&vlan_member_id, attr_count, attr_list);
      return vlan_member_id;
  }

  sai_thrift_status_t sai_thrift_remove_vlan_member(const sai_thrift_object_id_t vlan_member_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_vlan_api_t *vlan_api;
      status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = vlan_api->remove_vlan_member(vlan_member_id);
      return status;
  }

  void sai_thrift_get_vlan_stats(
          std::vector<int64_t> & thrift_counters,
          const sai_thrift_vlan_id_t vlan_id,
          const std::vector<sai_thrift_vlan_stat_t> & thrift_counter_ids,
          const int32_t number_of_counters) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_vlan_api_t *vlan_api;
      status = sai_api_query(SAI_API_VLAN, (void **) &vlan_api);
      if (status != SAI_STATUS_SUCCESS) {
          return;
      }
      sai_vlan_stat_t *counter_ids = (sai_vlan_stat_t *) malloc(sizeof(sai_vlan_stat_t) * thrift_counter_ids.size());
      std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
      uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
      for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
          counter_ids[i] = (sai_vlan_stat_t) *it;
      }

      status = vlan_api->get_vlan_stats(
                             (sai_vlan_id_t) vlan_id,
                             counter_ids,
                             number_of_counters,
                             counters);

      for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
          thrift_counters.push_back(counters[i]);
      }
      free(counter_ids);
      free(counters);
      return;
  }

  sai_thrift_object_id_t sai_thrift_create_virtual_router(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_virtual_router_api_t *vr_api;
      sai_object_id_t vr_id = 0;
      status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **) &vr_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_vr_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      vr_api->create_virtual_router(&vr_id, attr_count, attr_list);
      return vr_id;
  }

  sai_thrift_status_t sai_thrift_remove_virtual_router(const sai_thrift_object_id_t vr_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_virtual_router_api_t *vr_api;
      status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **) &vr_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = vr_api->remove_virtual_router((sai_object_id_t)vr_id);
      return status;
  }

  sai_thrift_status_t sai_thrift_create_route(const sai_thrift_route_entry_t& thrift_route_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_route_api_t *route_api;
      sai_route_entry_t route_entry;
      status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_route_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = route_api->create_route(&route_entry, attr_count, attr_list);
      free(attr_list);
      return status;
  }

  sai_thrift_status_t sai_thrift_remove_route(const sai_thrift_route_entry_t& thrift_route_entry) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_route_api_t *route_api;
      sai_route_entry_t route_entry;
      status = sai_api_query(SAI_API_ROUTE, (void **) &route_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
      status = route_api->remove_route(&route_entry);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_router_interface(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_router_interface_api_t *rif_api;
      sai_object_id_t rif_id = 0;
      status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_router_interface_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = rif_api->create_router_interface(&rif_id, attr_count, attr_list);
      return rif_id;
  }

  sai_thrift_status_t sai_thrift_remove_router_interface(const sai_thrift_object_id_t rif_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_router_interface_api_t *rif_api;
      status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = rif_api->remove_router_interface((sai_object_id_t)rif_id);
      return status;
  }

  void sai_thrift_get_router_interface_attribute(sai_thrift_get_response_t& _return, const sai_thrift_object_id_t rif_id,
          const int32_t attr_count, const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_router_interface_api_t *rif_api;
      status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **) &rif_api);
      if (status != SAI_STATUS_SUCCESS) {
          _return.status = status;;
          return;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_router_interface_attributes(thrift_attr_list, attr_list);
      status = rif_api->get_router_interface_attribute(rif_id, attr_count, attr_list);
      _return.status;

      sai_thrift_deparse_router_interface_attributes(_return.attributes, thrift_attr_list, attr_list);
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_next_hop_api_t *nhop_api;
      sai_object_id_t nhop_id = 0;
      status = sai_api_query(SAI_API_NEXT_HOP, (void **) &nhop_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_next_hop_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = nhop_api->create_next_hop(&nhop_id, attr_count, attr_list);
      return nhop_id;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_next_hop_api_t *nhop_api;
      status = sai_api_query(SAI_API_NEXT_HOP, (void **) &nhop_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = nhop_api->remove_next_hop((sai_object_id_t)next_hop_id);
      return status;
  }

  void sai_thrift_get_next_hop_attribute(sai_thrift_get_response_t & _return, const sai_thrift_object_id_t next_hop_id,
          const int32_t attr_count, const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_next_hop_api_t *nhop_api;
      status = sai_api_query(SAI_API_NEXT_HOP, (void **) &nhop_api);
      if (status != SAI_STATUS_SUCCESS) {
          _return.status = status;
          return;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_next_hop_attributes(thrift_attr_list, attr_list);

      status = nhop_api->get_next_hop_attribute(next_hop_id, attr_count, attr_list);
      _return.status = status;

      sai_thrift_deparse_next_hop_attributes(_return.attributes, thrift_attr_list, attr_list);
  }

  sai_thrift_status_t sai_thrift_set_next_hop_attribute(const sai_thrift_object_id_t next_hop_id, const std::vector<sai_thrift_attribute_t> & single_attribute) {

      // ensure singleton list
      assert(single_attribute.size() == 1);

      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_next_hop_api_t *nhop_api;
      status = sai_api_query(SAI_API_NEXT_HOP, (void **) &nhop_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * single_attribute.size());
      sai_thrift_parse_next_hop_attributes(single_attribute, attr_list);

      status = nhop_api->set_next_hop_attribute(next_hop_id, attr_list);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_next_hop_group_api_t *nhop_group_api;
      sai_object_id_t nhop_group_id = 0;
      sai_object_id_t *nhop_list = NULL;
      status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **) &nhop_group_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_next_hop_group_attributes(thrift_attr_list, attr_list, &nhop_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = nhop_group_api->create_next_hop_group(&nhop_group_id, attr_count, attr_list);
      if (nhop_list) free(nhop_list);
      free(attr_list);
      return nhop_group_id;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop_group(const sai_thrift_object_id_t next_hop_group_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_next_hop_group_api_t *nhop_group_api = NULL;
      status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **) &nhop_group_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = nhop_group_api->remove_next_hop_group(next_hop_group_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_next_hop_group_api_t *nhop_group_api = NULL;
      sai_object_id_t nhop_group_member_id = 0;
      status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **) &nhop_group_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_next_hop_group_member_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = nhop_group_api->create_next_hop_group_member(&nhop_group_member_id, attr_count, attr_list);
      free(attr_list);
      return nhop_group_member_id;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop_group_member(const sai_thrift_object_id_t next_hop_group_member_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_next_hop_group_api_t *nhop_group_api = NULL;
      status = sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **) &nhop_group_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = nhop_group_api->remove_next_hop_group_member(next_hop_group_member_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_lag(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_lag_api_t *lag_api;
      sai_object_id_t lag_id = 0;
      sai_attribute_t *attr_list = NULL;
      uint32_t attr_count = 0;
      status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = lag_api->create_lag(&lag_id, attr_count, attr_list);
      return lag_id;
  }

  sai_thrift_status_t sai_thrift_remove_lag(const sai_thrift_object_id_t lag_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_lag_api_t *lag_api;
      status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = lag_api->remove_lag((sai_object_id_t)lag_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_lag_member(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_lag_api_t *lag_api;
      sai_object_id_t lag_member_id;
      status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_lag_member_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = lag_api->create_lag_member(&lag_member_id, attr_count, attr_list);
      return lag_member_id;
  }

  sai_thrift_status_t sai_thrift_remove_lag_member(const sai_thrift_object_id_t lag_member_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_lag_api_t *lag_api;
      status = sai_api_query(SAI_API_LAG, (void **) &lag_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = lag_api->remove_lag_member(lag_member_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_stp(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_stp_api_t *stp_api;
      sai_vlan_id_t *vlan_list;
      sai_object_id_t stp_id;
      status = sai_api_query(SAI_API_STP, (void **) &stp_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_stp_attributes(thrift_attr_list, attr_list, &vlan_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = (sai_object_id_t) stp_api->create_stp(&stp_id, attr_count, attr_list);
      if (vlan_list) free(vlan_list);
      free(attr_list);
      return stp_id;
  }

  sai_thrift_status_t sai_thrift_remove_stp(const sai_thrift_object_id_t stp_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_stp_api_t *stp_api;
      status = sai_api_query(SAI_API_STP, (void **) &stp_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = (sai_thrift_status_t) stp_api->remove_stp(stp_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_stp_port(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_stp_api_t *stp_api = NULL;
      sai_object_id_t stp_port_id = 0;
      status = sai_api_query(SAI_API_STP, (void **) &stp_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_stp_port_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = (sai_object_id_t) stp_api->create_stp_port(&stp_port_id, attr_count, attr_list);
      free(attr_list);
      return stp_port_id;
  }

  sai_thrift_status_t sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_stp_api_t *stp_api;
      status = sai_api_query(SAI_API_STP, (void **) &stp_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = (sai_thrift_status_t) stp_api->remove_stp_port(stp_port_id);
      return status;
  }

  sai_thrift_status_t sai_thrift_create_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry, const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_neighbor_api_t *neighbor_api;
      status = sai_api_query(SAI_API_NEIGHBOR, (void **) &neighbor_api);
      sai_neighbor_entry_t neighbor_entry;
      memset(&neighbor_entry, 0, sizeof(neighbor_entry));
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_neighbor_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = neighbor_api->create_neighbor_entry(&neighbor_entry, attr_count, attr_list);
      free(attr_list);
      return status;
  }

  sai_thrift_status_t sai_thrift_remove_neighbor_entry(const sai_thrift_neighbor_entry_t& thrift_neighbor_entry) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_neighbor_api_t *neighbor_api;
      sai_neighbor_entry_t neighbor_entry;
      memset(&neighbor_entry, 0, sizeof(neighbor_entry));
      status = sai_api_query(SAI_API_NEIGHBOR, (void **) &neighbor_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
      status = neighbor_api->remove_neighbor_entry(&neighbor_entry);
      return status;
  }

  void sai_thrift_get_switch_attribute(sai_thrift_attribute_list_t& thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_switch_api_t *switch_api;
      sai_attribute_t max_port_attribute;
      sai_attribute_t port_list_object_attribute;
      sai_thrift_attribute_t thrift_port_list_attribute;
      sai_object_list_t *port_list_object;
      int max_ports = 0;
      status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
      if (status != SAI_STATUS_SUCCESS) {
          return;
      }

      max_port_attribute.id = SAI_SWITCH_ATTR_PORT_NUMBER;
      switch_api->get_switch_attribute(1, &max_port_attribute);
      max_ports = max_port_attribute.value.u32;
      port_list_object_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
      port_list_object_attribute.value.objlist.list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * max_ports);
      switch_api->get_switch_attribute(1, &port_list_object_attribute);

      thrift_attr_list.attr_count = 1;
      std::vector<sai_thrift_attribute_t>& attr_list = thrift_attr_list.attr_list;
      thrift_port_list_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
      thrift_port_list_attribute.value.objlist.count = max_ports;
      std::vector<sai_thrift_object_id_t>& port_list = thrift_port_list_attribute.value.objlist.object_id_list;
      port_list_object = &port_list_object_attribute.value.objlist;
      for (int index = 0; index < max_ports; index++) {
          port_list.push_back((sai_thrift_object_id_t) port_list_object->list[index]);
      }
      attr_list.push_back(thrift_port_list_attribute);
      free(port_list_object_attribute.value.objlist.list);
  }

  sai_thrift_status_t sai_thrift_set_switch_attribute(const sai_thrift_attribute_t& thrift_attr) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_switch_api_t *switch_api;
      sai_attribute_t attr;
      status = sai_api_query(SAI_API_SWITCH, (void **) &switch_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      attr.id = thrift_attr.id;
      switch(thrift_attr.id) {
          case SAI_SWITCH_ATTR_SRC_MAC_ADDRESS:
              sai_thrift_string_to_mac(thrift_attr.value.mac, attr.value.mac);
              break;
      }
      status = switch_api->set_switch_attribute(&attr);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_hostif_api_t *hostif_api;
      sai_object_id_t hif_id;
      status = sai_api_query(SAI_API_HOST_INTERFACE, (void **) &hostif_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_hostif_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = hostif_api->create_hostif(&hif_id, attr_count, attr_list);
      free(attr_list);
      return hif_id;
  }

  sai_thrift_status_t sai_thrift_remove_hostif(const sai_thrift_object_id_t hif_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_hostif_api_t *hostif_api;
      status = sai_api_query(SAI_API_HOST_INTERFACE, (void **) &hostif_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = hostif_api->remove_hostif((sai_object_id_t) hif_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap_group(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_hostif_api_t *hostif_api;
      sai_object_id_t hif_trap_group_id;
      status = sai_api_query(SAI_API_HOST_INTERFACE, (void **) &hostif_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_hostif_trap_group_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = hostif_api->create_hostif_trap_group(&hif_trap_group_id, attr_count, attr_list);
      free(attr_list);
      return hif_trap_group_id;
  }

  sai_thrift_status_t sai_thrift_remove_hostif_trap_group(const sai_thrift_object_id_t hif_trap_group_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_hostif_api_t *hostif_api;
      status = sai_api_query(SAI_API_HOST_INTERFACE, (void **) &hostif_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = hostif_api->remove_hostif_trap_group((sai_object_id_t) hif_trap_group_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api = NULL;
    sai_object_id_t hif_trap_id = 0;
    status = sai_api_query(SAI_API_HOST_INTERFACE, (void **) &hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
          return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_hostif_trap_attributes(thrift_attr_list, attr_list);
    uint32_t attr_count = thrift_attr_list.size();
    status = hostif_api->create_trap(&hif_trap_id, attr_count, attr_list);
    free(attr_list);
    return hif_trap_id;
  }

  sai_thrift_status_t sai_thrift_remove_hostif_trap(const sai_thrift_object_id_t hif_trap_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api = NULL;
    status = sai_api_query(SAI_API_HOST_INTERFACE, (void **) &hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
          return status;
    }
    status = hostif_api->remove_trap(hif_trap_id);
    return status;
  }

  void sai_thrift_parse_acl_table_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
            case SAI_ACL_TABLE_ATTR_STAGE:
                attr_list[i].value.s32 = attribute.value.s32;
                break;

            case SAI_ACL_TABLE_ATTR_FIELD_SRC_IPv6:
            case SAI_ACL_TABLE_ATTR_FIELD_DST_IPv6:
            case SAI_ACL_TABLE_ATTR_FIELD_SRC_MAC:
            case SAI_ACL_TABLE_ATTR_FIELD_DST_MAC:
            case SAI_ACL_TABLE_ATTR_FIELD_SRC_IP:
            case SAI_ACL_TABLE_ATTR_FIELD_DST_IP:
            case SAI_ACL_TABLE_ATTR_FIELD_IN_PORTS:
            case SAI_ACL_TABLE_ATTR_FIELD_OUT_PORTS:
            case SAI_ACL_TABLE_ATTR_FIELD_IN_PORT:
            case SAI_ACL_TABLE_ATTR_FIELD_OUT_PORT:
            case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_ID:
            case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_PRI:
            case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_CFI:
            case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_ID:
            case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_PRI:
            case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_CFI:
            case SAI_ACL_TABLE_ATTR_FIELD_L4_SRC_PORT:
            case SAI_ACL_TABLE_ATTR_FIELD_L4_DST_PORT:
            case SAI_ACL_TABLE_ATTR_FIELD_ETHER_TYPE:
            case SAI_ACL_TABLE_ATTR_FIELD_IP_PROTOCOL:
            case SAI_ACL_TABLE_ATTR_FIELD_DSCP:
            case SAI_ACL_TABLE_ATTR_FIELD_ECN:
            case SAI_ACL_TABLE_ATTR_FIELD_TTL:
            case SAI_ACL_TABLE_ATTR_FIELD_TOS:
            case SAI_ACL_TABLE_ATTR_FIELD_IP_FLAGS:
            case SAI_ACL_TABLE_ATTR_FIELD_TCP_FLAGS:
            case SAI_ACL_TABLE_ATTR_FIELD_IP_TYPE:
            case SAI_ACL_TABLE_ATTR_FIELD_IP_FRAG:
            case SAI_ACL_TABLE_ATTR_FIELD_IPv6_FLOW_LABEL:
            case SAI_ACL_TABLE_ATTR_FIELD_TC:
                break;
              default:
                break;
          }
      }
  }

  void sai_thrift_parse_acl_entry_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
            case SAI_ACL_ENTRY_ATTR_TABLE_ID:
                attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                break;
            case SAI_ACL_ENTRY_ATTR_PRIORITY:
                attr_list[i].value.aclfield.data.u32 = attribute.value.aclfield.data.u32;
                break;
            case SAI_ACL_ENTRY_ATTR_ADMIN_STATE:
                attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IPv6:
            case SAI_ACL_ENTRY_ATTR_FIELD_DST_IPv6:
                sai_thrift_string_to_v6_ip(attribute.value.aclfield.data.ip6, attr_list[i].value.aclfield.data.ip6);
                sai_thrift_string_to_v6_ip(attribute.value.aclfield.mask.ip6, attr_list[i].value.aclfield.mask.ip6);
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_SRC_MAC:
            case SAI_ACL_ENTRY_ATTR_FIELD_DST_MAC:
                sai_thrift_string_to_mac(attribute.value.aclfield.data.mac, attr_list[i].value.aclfield.data.mac);
                sai_thrift_string_to_mac(attribute.value.aclfield.mask.mac, attr_list[i].value.aclfield.mask.mac);
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IP:
            case SAI_ACL_ENTRY_ATTR_FIELD_DST_IP:
                sai_thrift_string_to_v4_ip(attribute.value.aclfield.data.ip4, &attr_list[i].value.aclfield.data.ip4);
                sai_thrift_string_to_v4_ip(attribute.value.aclfield.mask.ip4, &attr_list[i].value.aclfield.mask.ip4);
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORT:
                attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORTS:
                {
                    int count = attribute.value.aclfield.data.objlist.object_id_list.size();
                    sai_object_id_t *oid_list = NULL;
                    std::vector<sai_thrift_object_id_t>::const_iterator it = attribute.value.aclfield.data.objlist.object_id_list.begin();
                    oid_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * count);
                    for(int j = 0; j < count; j++, it++)
                        *(oid_list + j) = (sai_object_id_t) *it;
                    attr_list[i].value.aclfield.data.objlist.list =  oid_list;
                    attr_list[i].value.aclfield.data.objlist.count =  count;
                }
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORT:
                attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                break;
            /*
            case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORTS:
            */
            case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_PRI:
            case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_CFI:
            case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_PRI:
            case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_CFI:
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_ID:
            case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_ID:
            case SAI_ACL_ENTRY_ATTR_FIELD_L4_SRC_PORT:
            case SAI_ACL_ENTRY_ATTR_FIELD_L4_DST_PORT:
            case SAI_ACL_ENTRY_ATTR_FIELD_ETHER_TYPE:
                attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_IP_PROTOCOL:
            case SAI_ACL_ENTRY_ATTR_FIELD_DSCP:
            case SAI_ACL_ENTRY_ATTR_FIELD_ECN:
            case SAI_ACL_ENTRY_ATTR_FIELD_TTL:
            case SAI_ACL_ENTRY_ATTR_FIELD_TOS:
//            case SAI_ACL_ENTRY_ATTR_FIELD_IP_FLAGS:
            case SAI_ACL_ENTRY_ATTR_FIELD_TCP_FLAGS:
//            case SAI_ACL_ENTRY_ATTR_FIELD_IP_TYPE:
//            case SAI_ACL_ENTRY_ATTR_FIELD_IP_FRAG:
            case SAI_ACL_ENTRY_ATTR_FIELD_TC:
                attr_list[i].value.aclfield.data.u8 = attribute.value.aclfield.data.u8;
                attr_list[i].value.aclfield.mask.u8 = attribute.value.aclfield.mask.u8;
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_IPv6_FLOW_LABEL:
                attr_list[i].value.aclfield.data.u16 = attribute.value.aclfield.data.u16;
                attr_list[i].value.aclfield.mask.u16 = attribute.value.aclfield.mask.u16;
                break;
            case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_INGRESS:
                attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                break;
            case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_EGRESS:
                attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                break;
            case SAI_ACL_ENTRY_ATTR_ACTION_SET_POLICER:
                attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                break;
            case SAI_ACL_ENTRY_ATTR_ACTION_COUNTER:
                attr_list[i].value.aclfield.data.oid = attribute.value.aclfield.data.oid;
                break;
            case SAI_ACL_ENTRY_ATTR_ACTION_PACKET_ACTION:
                attr_list[i].value.aclfield.data.s32 = attribute.value.aclfield.data.s32;
                break;
            case SAI_ACL_ENTRY_ATTR_FIELD_RANGE:
                {
                    int count = attribute.value.aclfield.data.objlist.object_id_list.size();
                    sai_object_id_t *oid_list = NULL;
                    std::vector<sai_thrift_object_id_t>::const_iterator it = attribute.value.aclfield.data.objlist.object_id_list.begin();
                    oid_list = (sai_object_id_t *) malloc(sizeof(sai_object_id_t) * count);
                    for(int j = 0; j < count; j++, it++)
                        *(oid_list + j) = (sai_object_id_t) *it;
                    attr_list[i].value.aclfield.data.objlist.list = oid_list;
                    attr_list[i].value.aclfield.data.objlist.count =  count;
                }
                break;
              default:
                break;
          }
      }
  }

  void sai_thrift_convert_to_acl_range_attributes(
          const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
          sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_ACL_RANGE_ATTR_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_ACL_RANGE_ATTR_LIMIT:
                  attr_list[i].value.u32range.min = attribute.value.u32range.min;
                  attr_list[i].value.u32range.max = attribute.value.u32range.max;
                  break;
          }
      }
  }

  void sai_thrift_convert_to_acl_counter_attributes(
          const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
          sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_ACL_COUNTER_ATTR_TABLE_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT:
                  attr_list[i].value.booldata = attribute.value.booldata;
                  break;
              case SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT:
                  attr_list[i].value.booldata = attribute.value.booldata;
                  break;
              case SAI_ACL_COUNTER_ATTR_PACKETS:
                  attr_list[i].value.u64= attribute.value.u64;
                  break;
              case SAI_ACL_COUNTER_ATTR_BYTES:
                  attr_list[i].value.u64= attribute.value.u64;
                  break;
          }
      }
  }
  void sai_thrift_convert_to_acl_thrift_counter_attributes(
          sai_attribute_t *attr_list,
          uint32_t attr_count,
          std::vector<sai_thrift_attribute_value_t> &thrift_attr_value_list) {
      sai_attribute_t attribute;
      sai_thrift_attribute_value_t thrift_attribute_value;
      for(uint32_t i = 0; i < attr_count; i++) {
          attribute = attr_list[i];
          switch (attribute.id) {
              case SAI_ACL_COUNTER_ATTR_TABLE_ID:
                  thrift_attribute_value.oid = attribute.value.oid;
                  break;
              case SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT:
                  thrift_attribute_value.booldata = attribute.value.booldata;
                  break;
              case SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT:
                  thrift_attribute_value.booldata = attribute.value.booldata;
                  break;
              case SAI_ACL_COUNTER_ATTR_PACKETS:
                  thrift_attribute_value.u64= attribute.value.u64;
                  break;
              case SAI_ACL_COUNTER_ATTR_BYTES:
                  thrift_attribute_value.u64= attribute.value.u64;
                  break;
          }
          thrift_attr_value_list.push_back(thrift_attribute_value);
      }
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_object_id_t acl_table = 0ULL;
      sai_acl_api_t *acl_api;
      sai_status_t status = SAI_STATUS_SUCCESS;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }

      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_acl_table_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = acl_api->create_acl_table(&acl_table, attr_count, attr_list);
      free(attr_list);
      return acl_table;
  }

  sai_thrift_status_t sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_acl_api_t *acl_api;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = acl_api->remove_acl_table(acl_table_id);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_entry(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_object_id_t acl_entry = 0ULL;
      sai_acl_api_t *acl_api;
      sai_status_t status = SAI_STATUS_SUCCESS;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }

      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_acl_entry_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = acl_api->create_acl_entry(&acl_entry, attr_count, attr_list);
      free(attr_list);
      return acl_entry;
  }

  sai_thrift_status_t sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_acl_api_t *acl_api;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = acl_api->remove_acl_entry(acl_entry);
      return status;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_counter(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_object_id_t acl_counter_id = 0ULL;
      sai_acl_api_t *acl_api;
      sai_status_t status = SAI_STATUS_SUCCESS;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_convert_to_acl_counter_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = acl_api->create_acl_counter(&acl_counter_id, attr_count, attr_list);
      free(attr_list);
      return acl_counter_id;
  }

  sai_thrift_status_t sai_thrift_remove_acl_counter(const sai_thrift_object_id_t acl_counter_id) {
      sai_object_id_t acl_entry = 0ULL;
      sai_acl_api_t *acl_api;
      sai_status_t status = SAI_STATUS_SUCCESS;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = acl_api->remove_acl_counter(acl_counter_id);
      return status;
  }

  void sai_thrift_get_acl_counter_attribute(
          std::vector<sai_thrift_attribute_value_t> & thrift_attr_values,
          const sai_thrift_object_id_t acl_counter_id,
          const std::vector<int32_t> & thrift_attr_ids) {
      sai_object_id_t acl_entry = 0ULL;
      sai_acl_api_t *acl_api;
      sai_status_t status = SAI_STATUS_SUCCESS;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return;
      }

      uint32_t attr_count = thrift_attr_ids.size();
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_ids.size());
      memset(attr_list, 0x0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
      sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
      status = acl_api->get_acl_counter_attribute(
                             acl_counter_id,
                             attr_count,
                             attr_list);
      if (status != SAI_STATUS_SUCCESS) {
          return;
      }

      sai_thrift_convert_to_acl_thrift_counter_attributes(
                             attr_list,
                             attr_count,
                             thrift_attr_values);
      return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_range(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_object_id_t acl_range_id = 0ULL;
      sai_acl_api_t *acl_api;
      sai_status_t status = SAI_STATUS_SUCCESS;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_convert_to_acl_range_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      status = acl_api->create_acl_range(&acl_range_id, attr_count, attr_list);
      free(attr_list);
      return acl_range_id;
  }

  sai_thrift_status_t sai_thrift_delete_acl_range(const sai_thrift_object_id_t acl_range_id) {
      sai_object_id_t acl_entry = 0ULL;
      sai_acl_api_t *acl_api;
      sai_status_t status = SAI_STATUS_SUCCESS;
      status = sai_api_query(SAI_API_ACL, (void **) &acl_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = acl_api->remove_acl_range(acl_range_id);
      return status;
  }

  void sai_thrift_parse_mirror_session_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_MIRROR_SESSION_ATTR_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_MIRROR_SESSION_ATTR_MONITOR_PORT:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_MIRROR_SESSION_ATTR_TC:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_MIRROR_SESSION_ATTR_VLAN_TPID:
                  attr_list[i].value.u16 = attribute.value.u16;
                  break;
              case SAI_MIRROR_SESSION_ATTR_VLAN_ID:
                  attr_list[i].value.u16 = attribute.value.u16;
                  break;
              case SAI_MIRROR_SESSION_ATTR_VLAN_PRI:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_MIRROR_SESSION_ATTR_ENCAP_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_MIRROR_SESSION_ATTR_IPHDR_VERSION:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_MIRROR_SESSION_ATTR_TOS:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_MIRROR_SESSION_ATTR_TTL:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_MIRROR_SESSION_ATTR_SRC_IP_ADDRESS:
                  sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                  break;
              case SAI_MIRROR_SESSION_ATTR_DST_IP_ADDRESS:
                  sai_thrift_parse_ip_address(attribute.value.ipaddr, &attr_list[i].value.ipaddr);
                  break;
              case SAI_MIRROR_SESSION_ATTR_SRC_MAC_ADDRESS:
                  sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                  break;
              case SAI_MIRROR_SESSION_ATTR_DST_MAC_ADDRESS:
                  sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
                  break;
              case SAI_MIRROR_SESSION_ATTR_GRE_PROTOCOL_TYPE:
                  attr_list[i].value.u16 = attribute.value.u16;
                  break;
              default:
                  break;
          }
      }
  }

  sai_thrift_object_id_t sai_thrift_create_mirror_session(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_mirror_api_t *mirror_api;
      sai_object_id_t session_id = 0;
      status = sai_api_query(SAI_API_MIRROR, (void **) &mirror_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_mirror_session_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      mirror_api->create_mirror_session(&session_id, attr_count, attr_list);
      free(attr_list);
      return session_id;
  }

  sai_thrift_status_t sai_thrift_remove_mirror_session(const sai_thrift_object_id_t session_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_mirror_api_t *mirror_api;
      status = sai_api_query(SAI_API_MIRROR, (void **) &mirror_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = mirror_api->remove_mirror_session((sai_object_id_t) session_id);
      return status;
  }

  void sai_thrift_parse_policer_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_POLICER_ATTR_METER_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_POLICER_ATTR_MODE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_POLICER_ATTR_COLOR_SOURCE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_POLICER_ATTR_CBS:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              case SAI_POLICER_ATTR_CIR:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              case SAI_POLICER_ATTR_PBS:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              case SAI_POLICER_ATTR_PIR:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              case SAI_POLICER_ATTR_GREEN_PACKET_ACTION:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_POLICER_ATTR_YELLOW_PACKET_ACTION:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
              case SAI_POLICER_ATTR_RED_PACKET_ACTION:
                  attr_list[i].value.s32 = attribute.value.s32;
                  break;
          }
      }
  }

  sai_thrift_object_id_t sai_thrift_create_policer(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_policer_api_t *policer_api;
      sai_object_id_t policer_id = 0;
      status = sai_api_query(SAI_API_POLICER, (void **) &policer_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_policer_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      policer_api->create_policer(&policer_id, attr_count, attr_list);
      free(attr_list);
      return policer_id;
  }

  sai_thrift_status_t sai_thrift_remove_policer(const sai_thrift_object_id_t policer_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_policer_api_t *policer_api;
      status = sai_api_query(SAI_API_POLICER, (void **) &policer_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = policer_api->remove_policer((sai_object_id_t) policer_id);
      return status;
  }

  void sai_thrift_get_policer_stats(
          std::vector<int64_t> & thrift_counters,
          const sai_thrift_object_id_t policer_id,
          const std::vector<sai_thrift_policer_stat_t> & thrift_counter_ids) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_policer_api_t *policer_api;
      status = sai_api_query(SAI_API_POLICER, (void **) &policer_api);
      if (status != SAI_STATUS_SUCCESS) {
          return;
      }
      sai_policer_stat_t *counter_ids = (sai_policer_stat_t *) malloc(sizeof(sai_policer_stat_t) * thrift_counter_ids.size());
      std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
      uint64_t *counters = (uint64_t *) malloc(sizeof(uint64_t) * thrift_counter_ids.size());
      for(uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
          counter_ids[i] = (sai_policer_stat_t) *it;
      }

      int32_t number_of_counters = thrift_counter_ids.size();
      status = policer_api->get_policer_statistics(
                             (sai_object_id_t) policer_id,
                             counter_ids,
                             number_of_counters,
                             counters);

      for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
          thrift_counters.push_back(counters[i]);
      }
      free(counter_ids);
      free(counters);
      return;
  }

  void sai_thrift_parse_buffer_pool_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_BUFFER_POOL_ATTR_SHARED_SIZE:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_BUFFER_POOL_ATTR_TYPE:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_BUFFER_POOL_ATTR_SIZE:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_BUFFER_POOL_ATTR_TH_MODE:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
          }
      }
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_pool(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_buffer_api_t *buffer_api;
      sai_object_id_t pool_id = 0;
      status = sai_api_query(SAI_API_BUFFERS, (void **) &buffer_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_buffer_pool_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      buffer_api->create_buffer_pool(&pool_id, attr_count, attr_list);
      free(attr_list);
      return pool_id;
  }

  sai_thrift_status_t sai_thrift_remove_buffer_pool(const sai_thrift_object_id_t pool_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_buffer_api_t *buffer_api;
      status = sai_api_query(SAI_API_BUFFERS, (void **) &buffer_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = buffer_api->remove_buffer_pool(pool_id);
      return status;
  }

  void sai_thrift_parse_buffer_profile_attributes(const std::vector<sai_thrift_attribute_t> &thrift_attr_list, sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_BUFFER_PROFILE_ATTR_POOL_ID:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              case SAI_BUFFER_PROFILE_ATTR_BUFFER_SIZE:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_BUFFER_PROFILE_ATTR_SHARED_DYNAMIC_TH:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_BUFFER_PROFILE_ATTR_SHARED_STATIC_TH:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_BUFFER_PROFILE_ATTR_XOFF_TH:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_BUFFER_PROFILE_ATTR_XON_TH:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
          }
      }
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_profile(const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_buffer_api_t *buffer_api;
      sai_object_id_t buffer_profile_id = 0;
      status = sai_api_query(SAI_API_BUFFERS, (void **) &buffer_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_buffer_profile_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      buffer_api->create_buffer_profile(&buffer_profile_id, attr_count, attr_list);
      free(attr_list);
      return buffer_profile_id;
  }

  sai_thrift_status_t sai_thrift_remove_buffer_profile(const sai_thrift_object_id_t buffer_profile_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_buffer_api_t *buffer_api;
      status = sai_api_query(SAI_API_BUFFERS, (void **) &buffer_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = buffer_api->remove_buffer_profile(buffer_profile_id);
      return status;
  }

  sai_thrift_status_t sai_thrift_set_ingress_priority_group_attribute(
          const sai_thrift_object_id_t ingress_pg_id,
          const sai_thrift_attribute_t& thrift_attr) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_buffer_api_t *buffer_api;
      status = sai_api_query(SAI_API_BUFFERS, (void **) &buffer_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t attr;
      memset(&attr, 0x0, sizeof(sai_attribute_t));
      attr.id = thrift_attr.id;
      attr.value.oid = thrift_attr.value.oid;

      status = buffer_api->set_ingress_priority_group_attr(ingress_pg_id, &attr);
      return status;
  }

  void sai_thrift_parse_scheduler_profile_attributes(
          const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
          sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_SCHEDULER_ATTR_SCHEDULING_ALGORITHM:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_SCHEDULER_ATTR_SHAPER_TYPE:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE:
                  attr_list[i].value.u64 = attribute.value.u64;
                  break;
              default:
                  break;
          }
      }
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_profile(
          const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_scheduler_api_t *scheduler_api;
      sai_object_id_t scheduler_id = 0;
      status = sai_api_query(SAI_API_SCHEDULER, (void **) &scheduler_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_scheduler_profile_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      scheduler_api->create_scheduler_profile(&scheduler_id, attr_count, attr_list);
      free(attr_list);
      return scheduler_id;
  }

  sai_thrift_status_t sai_thrift_remove_scheduler_profile(
          const sai_thrift_object_id_t scheduler_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_scheduler_api_t *scheduler_api;
      status = sai_api_query(SAI_API_SCHEDULER, (void **) &scheduler_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = scheduler_api->remove_scheduler_profile(scheduler_id);
      return status;
  }

  void sai_thrift_parse_scheduler_group_attributes(
          const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
          sai_attribute_t *attr_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_SCHEDULER_GROUP_ATTR_CHILD_COUNT:
                  attr_list[i].value.u32 = attribute.value.u32;
                  break;
              case SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST:
                  break;
              case SAI_SCHEDULER_GROUP_ATTR_PORT_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
              case SAI_SCHEDULER_GROUP_ATTR_LEVEL:
                  attr_list[i].value.u8 = attribute.value.u8;
                  break;
              case SAI_SCHEDULER_GROUP_ATTR_SCHEDULER_PROFILE_ID:
                  attr_list[i].value.oid = attribute.value.oid;
                  break;
          }
      }
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_group(
          const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_scheduler_group_api_t *scheduler_group_api;
      sai_object_id_t scheduler_group_id = 0;
      status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **) &scheduler_group_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_scheduler_group_attributes(thrift_attr_list, attr_list);
      uint32_t attr_count = thrift_attr_list.size();
      scheduler_group_api->create_scheduler_group(&scheduler_group_id, attr_count, attr_list);
      free(attr_list);
      return scheduler_group_id;
  }

  sai_thrift_status_t sai_thrift_remove_scheduler_group(
          const sai_thrift_object_id_t scheduler_group_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_scheduler_group_api_t *scheduler_group_api;
      status = sai_api_query(SAI_API_SCHEDULER_GROUP, (void **) &scheduler_group_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = scheduler_group_api->remove_scheduler_group(scheduler_group_id);
      return status;
  }

  void sai_thrift_parse_qos_map_attributes(
          const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
          sai_attribute_t *attr_list,
          sai_qos_map_t **qos_map_list) {
      std::vector<sai_thrift_attribute_t>::const_iterator it = thrift_attr_list.begin();
      sai_thrift_attribute_t attribute;
      sai_qos_map_type_t qos_map_type = (sai_qos_map_type_t) 0;
      for(uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
          attribute = (sai_thrift_attribute_t)*it;
          attr_list[i].id = attribute.id;
          switch (attribute.id) {
              case SAI_QOS_MAP_ATTR_TYPE:
                  attr_list[i].value.s32 = attribute.value.s32;
                  qos_map_type = (sai_qos_map_type_t) attribute.value.s32;
                  break;
              case SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST:
                  attr_list[i].value.qosmap.list = (sai_qos_map_t *) malloc(attribute.value.qosmap.key.size() * sizeof(sai_qos_map_t));
                  attr_list[i].value.qosmap.count = attribute.value.qosmap.key.size();
                  *qos_map_list = attr_list[i].value.qosmap.list;
                  memset(attr_list[i].value.qosmap.list, 0x0, attribute.value.qosmap.key.size() * sizeof(sai_qos_map_t));
                  std::vector<sai_thrift_qos_map_params_t>::const_iterator it1 = attribute.value.qosmap.key.begin();
                  std::vector<sai_thrift_qos_map_params_t>::const_iterator it2 = attribute.value.qosmap.data.begin();
                  for (uint32_t j = 0; j < attribute.value.qosmap.key.size(); j++, it1++, it2++) {
                      sai_qos_map_params_t *key = &attr_list[i].value.qosmap.list[j].key;
                      sai_qos_map_params_t *data = &attr_list[i].value.qosmap.list[j].value;
                      const sai_thrift_qos_map_params_t thrift_key = (sai_thrift_qos_map_params_t) *it1;
                      const sai_thrift_qos_map_params_t thrift_data = (sai_thrift_qos_map_params_t) *it2;

                      switch (qos_map_type) {
                          case SAI_QOS_MAP_TYPE_DOT1P_TO_TC:
                              key->dot1p = thrift_key.dot1p;
                              data->tc = thrift_data.tc;
                              break;
                          case SAI_QOS_MAP_TYPE_DOT1P_TO_COLOR:
                              key->dot1p = thrift_key.dot1p;
                              data->color = (sai_packet_color_t) thrift_data.color;
                              break;
                          case SAI_QOS_MAP_TYPE_DSCP_TO_TC:
                              key->dscp = thrift_key.dscp;
                              data->tc = thrift_data.tc;
                              break;
                          case SAI_QOS_MAP_TYPE_DSCP_TO_COLOR:
                              key->dscp = thrift_key.dscp;
                              data->color = (sai_packet_color_t) thrift_data.color;
                              break;
                          case SAI_QOS_MAP_TYPE_TC_TO_QUEUE:
                              key->tc = thrift_key.tc;
                              data->queue_index = thrift_data.queue_index;
                              break;
                          case SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP:
                              key->tc = thrift_key.tc;
                              key->color = (sai_packet_color_t) thrift_key.color;
                              data->dscp = thrift_data.dscp;
                              break;
                          case SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DOT1P:
                              key->tc = thrift_key.tc;
                              key->color = (sai_packet_color_t) thrift_key.color;
                              data->dot1p = thrift_data.dot1p;
                              break;
                          default:
                              break;
                      }
                  }
                  break;
          }
      }
  }

  sai_thrift_object_id_t sai_thrift_create_qos_map(
          const std::vector<sai_thrift_attribute_t> & thrift_attr_list) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_qos_map_api_t *qos_api;
      sai_object_id_t qos_map_id = 0;
      sai_qos_map_t *qos_map_list = NULL;
      status = sai_api_query(SAI_API_QOS_MAPS, (void **) &qos_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      sai_attribute_t *attr_list = (sai_attribute_t *) malloc(sizeof(sai_attribute_t) * thrift_attr_list.size());
      sai_thrift_parse_qos_map_attributes(thrift_attr_list, attr_list, &qos_map_list);
      uint32_t attr_count = thrift_attr_list.size();
      qos_api->create_qos_map(&qos_map_id, attr_count, attr_list);
      if (qos_map_list) {
          free(qos_map_list);
      }
      free(attr_list);
      return qos_map_id;
  }

  sai_thrift_status_t sai_thrift_remove_qos_map(
          const sai_thrift_object_id_t qos_map_id) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_qos_map_api_t *qos_api;
      status = sai_api_query(SAI_API_QOS_MAPS, (void **) &qos_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }
      status = qos_api->remove_qos_map(qos_map_id);
      return status;
  }

  sai_thrift_status_t sai_thrift_set_queue_attribute(
          const sai_thrift_object_id_t queue_id,
          const sai_thrift_attribute_t& thrift_attr) {
      sai_status_t status = SAI_STATUS_SUCCESS;
      sai_queue_api_t *queue_api;
      status = sai_api_query(SAI_API_QUEUE, (void **) &queue_api);
      if (status != SAI_STATUS_SUCCESS) {
          return status;
      }

      sai_attribute_t attr;
      memset(&attr, 0x0, sizeof(sai_attribute_t));
      attr.id = thrift_attr.id;
      attr.value.oid = thrift_attr.value.oid;
      status = queue_api->set_queue_attribute(queue_id, &attr);
      return status;
  }

};

static void * switch_sai_thrift_rpc_server_thread(void *arg) {
  int port = *(int *) arg;
  shared_ptr<switch_sai_rpcHandler> handler(new switch_sai_rpcHandler());
  shared_ptr<TProcessor> processor(new switch_sai_rpcProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

static pthread_t switch_sai_thrift_rpc_thread;

extern "C" {
extern void sai_initialize(void);

int start_p4_sai_thrift_rpc_server(char *port)
{
    std::cerr << "Starting SAI RPC server on port " << port << std::endl;

    int *port_arg = (int *) malloc(sizeof(int));
    *port_arg = atoi(port);

    sai_initialize();

    return pthread_create(&switch_sai_thrift_rpc_thread, NULL, switch_sai_thrift_rpc_server_thread, port_arg);
}
}
